<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Data Contract vs. Data Product Specifications - Blog Post</title>
    
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
    
    <style>
         html {
            scroll-behavior: smooth;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }

        header {
            background-color: #FF5722;
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            box-sizing: border-box;
        }

        .header-left {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 0;
            /* Allow shrinking */
            overflow: hidden;
            /* Prevent overflow */
        }

        .header-image {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            vertical-align: middle;
            flex-shrink: 0;
            /* Prevent image from shrinking */
        }

        .header-title {
            color: white;
            font-size: 24px;
            font-weight: bold;
            margin-left: 20px;
            line-height: 40px;
            /* Ensures the text is vertically centered with the image */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* Add ellipsis when text overflows */
        }

        .header-title a {
            text-decoration: none;
            color: white;
        }

        nav {
            display: flex;
            gap: 10px;
            margin-left: 20px;
            /* Add spacing between title and nav */
            flex-shrink: 0;
            /* Prevent nav from shrinking */
        }

        nav a {
            display: inline-block;
            padding: 8px 12px;
            text-decoration: none;
            background: white;
            color: #FF5722;
            border-radius: 5px;
            transition: background 0.3s, color 0.3s;
            white-space: nowrap;
            box-sizing: border-box;
            border: none;
        }

        nav a:hover {
            background: #FF8A65;
            color: white;
        }

        /* Hamburger menu for mobile */
        .menu-toggle {
            display: none;
            cursor: pointer;
            font-size: 24px;
            color: white;
            flex-shrink: 0;
            /* Prevent toggle from shrinking */
        }

        /* Media query for responsive design */
        @media screen and (max-width: 768px) {
            header {
                position: fixed;
                flex-wrap: wrap;
            }

            .header-left {
                flex: 1;
                min-width: 0;
                max-width: calc(100% - 50px);
                /* Make room for menu toggle */
            }

            .menu-toggle {
                display: block;
            }

            nav {
                display: none;
                width: 100%;
                flex-direction: column;
                margin-top: 15px;
                margin-left: 0; /* Reset margin-left for mobile */
                padding: 0 20px; /* Add horizontal padding to contain buttons */
                order: 3;
                box-sizing: border-box;
            }

            nav.active {
                display: flex;
            }

            nav a {
                width: auto; /* Use auto instead of 100% */
                margin: 5px 0;
                padding: 8px 12px;
                text-align: center;
                box-sizing: border-box;
                border-radius: 5px;
            }
        }

        /* Additional media query for very small screens */
        @media screen and (max-width: 480px) {
            .header-left {
                max-width: calc(100% - 40px);
                /* Make room for menu toggle */
            }

            .header-title {
                font-size: 20px;
                margin-left: 10px;
                max-width: calc(100% - 50px);
                /* Ensure title doesn't push menu toggle off screen */
            }

            .menu-toggle {
                margin-left: 5px;
                /* Add a small gap between title and menu toggle */
            }

            nav {
                padding: 0 20px; /* Maintain horizontal padding on smaller screens */
            }

            nav a {
                padding: 6px 10px;
                font-size: 14px;
            }
        }

        .container {
            width: 90%;
            max-width: 1000px;
            margin: 20px auto;
            padding: 80px 20px 20px 20px;
            /* Adjusted for the fixed header */
        }

        .post-title {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            color: #FF5722;
            margin-top: 20px;
            width: 100%;
        }

        .post-subtitle {
            font-size: 24px;
            font-weight: normal;
            text-align: center;
            color: #666;
            margin-top: 10px;
            margin-bottom: 20px;
            width: 100%;
        }

        .post-meta {
            text-align: center;
            font-size: 14px;
            color: #777;
            margin-bottom: 20px;
            width: 100%;
        }

        .post-meta a {
            color: #4e4c4c;
        }

        .post-meta a:hover {
            color: #1e1d1d;
        }


        .banner-box {
            background-color: #fae5c3;
            width: 100%;
            box-sizing: border-box;
            padding: 0px;
            border-radius: 15px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
        }

        .banner-image {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
            object-fit: cover;
            max-height: 400px;
        }

        .abstract-box {
            width: 100%;
            margin: 40px auto;

            box-sizing: border-box;
            padding: 20px;

            background-color: #fae5c3;
            border-radius: 15px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);

            line-height: 1.8;
            font-size: 18px;
        }

        .abstract-box a {
            color: #FF5722;
            text-decoration: none;
            transition: background 0.3s;
        }

        .abstract-box a:hover {
            text-decoration: underline;
        }


        .section {
            width: 100%;
            margin: 40px auto;
            box-sizing: border-box;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            font-size: 26px;
            font-weight: bold;
        }

        .section h3 {
            color: #242120;
            font-size: 22px;
            font-weight: bold;
        }

        .section p,
        .section ol,
        .section ul {
            font-size: 20px;
            line-height: 1.8;
            color: #555;
        }

        .section a {
            color: #FF5722;
            text-decoration: none;
            transition: background 0.3s;
        }

        .section a:hover {
            background-color: #fae5c3;
            text-decoration: none;
        }

        .section blockquote {
            border-left: 5px solid #FF5722;
            padding: 15px;
            font-style: italic;
            color: #4e4c4c;
            background-color: #fae5c3;
            margin: 20px;
            line-height: 1.8;
            font-size: 20px;
        }

        .section img {
            width: 80%;
            margin: 20px auto;
            display: block;
            border-radius: 8px;
        }

        .image-caption {
            text-align: center;
            font-size: 14px;
            color: #777;
            margin-top: 5px;
        }

        .section pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }

        .section code {
            font-family: monospace;
        }

        .resources-box {
            background-color: #fae5c3;
            width: 100%;
            margin: 40px auto;

            box-sizing: border-box;
            padding: 20px;

            border-radius: 15px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
            line-height: 1.8;
            font-size: 18px;
        }


        .resources-box {
            list-style: none;
        }

        .resources-box a {
            text-decoration: none;
            color: #FF5722;

        }

        .resources-box a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <header>
        <div class="header-left">
            <a href="../index.html">
                <img src="../../images/me.png" alt="Andrea Gioia" class="header-image">
            </a>
            <div class="header-title">
                > <a href="../blog.html">BLOG</a> / POST-25-002
            </div>
        </div>
        <div class="menu-toggle">☰</div>
        <nav>
            <a href="../../book/book.html">Book</a>
            <a href="....//podcast/podcast.html">Podcast</a>
            <a href="../../rants/rants.html">Rants</a>
            <a href="../../blog/blog.html">Blog</a>
            <a href="../../talks/talks.html">Talks</a>
        </nav>
    </header>
    

    <div class="container">
        <h1 class="post-title">Data Contract vs. Data Product Specifications</h1>
        <h2 class="post-subtitle">Friends, Enemies, or Frenemies?</h2>
        <p class="post-meta">10 min read - Published on Feb 9, 2025
            by <a href="../../index.html">Andrea Gioia</a>
            on <a
                href="https://medium.com/@andrea_gioia/data-contract-vs-data-product-specifications-8ffa3cc16725">Medium</a>
        </p>

        <div class="banner-box">
            <img class="banner-image" src="./images/2025-B002-Banner.png" alt="Post Banner">
        </div>


        <div class="abstract-box">
            <p>With the rise of data mesh, managing data as a product has become a hot topic within the data community.
                This shift has sparked numerous initiatives to define a common specification for formally describing
                data assets managed as products.
            </p>

            <p>However, not all specifications approach this in the same way. Some focus primarily on the data asset
                itself, detailing its structure and metadata. Others take a broader perspective, describing the data
                product as a whole, including its exposed services (i.e. ports) and internal components.
            </p>

            <p>These two approaches have led to two distinct types of specifications:

            <ul>
                <li> <b>Contract Specifications</b>, which focus on defining the structure of a data asset and all
                    associated
                    metadata.</li>
                <li><b>Data Product Specifications</b>, which focus on defining how a data product manages, exposes, and
                    serves
                    its data assets.</li>
            </ul>
            <p>In this blog post, I will explore both perspectives using two key examples:</p>


            <ul>
                <li>The <b><a
                            onclick="window.open('https://bitol-io.github.io/open-data-contract-standard/latest/', '_blank')">Data
                            Contract Standard (ODCS)</a></b>
                    from the <a onclick="window.open('https://bitol.io/', '_blank')">Bitol Project</a> as an example of
                    a data contract
                    specification.</li>
                <li>The <b><a
                            onclick="window.open('https://dpds.opendatamesh.org/specifications/dpds/1.0.0/', '_blank')">Data
                            Product Descriptor Specification (DPDS)</a></b>
                    from the <a onclick="window.open('https://initiative.opendatamesh.org/', '_blank')">Open Data Mesh
                        Initiative</a> as an example of
                    a data product specification.</li>
            </ul>

            <p>By comparing these two approaches, I’ll show why they are not mutually exclusive but can work best when
                used together. </p>
        </div>

        <div class="section">
            <h2> What makes them different</h2>

            <p>A <b>pure data product</b> is a software application that focuses on exposing data assets to potential
                consumers in a way that ensures their <b>relevance</b>, <b>accuracy</b>, <b>usability</b>, and
                <b>composability</b> over time. In summary, pure data products aim to increase the potential value of
                managed data assets by making them available for the implementation of multiple use cases over time.
            </p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-01-pure-data-product.png"
                alt="Pure Data Products">
            <div class="image-caption">Pure Data Products</div>

            <p>A pure data product manages and makes one or more data assets available for use. <b>Data Contract
                    Specifications (DCS)</b> focus on defining how to describe the data assets being shared, while
                <b>Data Product Specifications (DPS)</b> focus on how to describe the data products that handle and
                expose those assets.
            </p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-02-dps-vs-dcs.png"
                alt="DPS vs DCS">
            <div class="image-caption">DPS vs DCS</div>

            <p>A DCS can be used to describe a <b>data asset</b> from multiple perspectives, including:</p>
            <ul>
                <li>The data model</li>
                <li>Constraints applied to different elements of the model</li>
                <li>Quality metrics and corresponding tests</li>
                <li>Quality indicators with associated SLOs/SALs</li>
                <li>Data provenance and static lineage tracking</li>
                <li>Links to other data assets (syntactic links)</li>
                <li>Connections to business terms or concepts (semantic links)</li>
            </ul>

            <p>A DPS, on the other hand, can be used to describe a <b>pure data product</b> from multiple perspectives,
                including:</p>
            <ul>
                <li>Types of exposed services (ports)</li>
                <li>APIs of the exposed services</li>
                <li>Applicable SLOs/SLAs for the services</li>
                <li>Terms of use</li>
                <li>Billing policies for service usage</li>
                <li>Internal application components</li>
                <li>Internal infrastructure components</li>
                <li>Lifecycle management</li>
                <li>Dependencies between products</li>
            </ul>

            <p>To better understand the structure and practical applications of DPS and DCS, let’s explore two concrete
                examples, analyzing them separately before examining their overlaps and potential integrations.</p>

            <h2>Open Data Contract Standard</h2>

            <p><b>Open Data Contract Standard (ODCS)</b> is a well-known example of a Data Contract Standard (DCS)
                developed by the <a href="https://bitol.io/">Bitol Project</a>.</p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-03-odcs.png"
                alt="Open Data Contract Standard (ODCS)">
            <div class="image-caption">Open Data Contract Standard (ODCS)</div>

            <p>In ODCS’s <a
                    href="https://github.com/bitol-io/open-data-contract-standard/blob/main/schema/odcs-json-schema-latest.json">metamodel</a>,
                a data asset is represented as an <b>object</b> with various <b>properties</b>. Each property has a
                <b>unique name</b> within its object and a defined <b>data type</b>. The type can be either primitive
                (e.g., `int`, `string`, `boolean`) or composite (e.g., `object` or `array`).
            </p>

            <p>Thanks to this flexible structure, ODCS can describe both <b>tabular data assets</b> — where entries
                consist solely of primitive types — and <b>document-based data assets</b>, where entries can include
                composite types, creating a nested structure instead of a simple flat one.</p>

            <p>To define the structure of a specific data asset, ODCS uses <a
                    href="https://github.com/bitol-io/open-data-contract-standard/blob/main/schema/odcs-json-schema-latest.json">JSON
                    Schema</a> as its schema definition language (SCD), preferring YAML over JSON as the encoding
                format.</p>

            <pre><code class="yaml">
            version: 1.0.0

            schema:
            - name: tbl
                logicalType: object
                properties:
                - name: txn_ref_dt
                    logicalType: date
                - name: rcvr_id
                    logicalType: string
                - name: rcvr_cntry_code
                    logicalType: string
            </code></pre>

            <p>Structural elements of the model can be enriched with various descriptive metadata, grouped into the
                following ten main schema annotation vocabularies:</p>

            <ul>
                <li><b>Fundamentals</b> (e.g., name, version, descriptions…)</li>
                <li><b>Schema</b> (logical and physical metadata)</li>
                <li><b>Data Quality</b> (data quality rules and data governance policies)</li>
                <li><b>Pricing</b> (internal or external costs associated with usage)</li>
                <li><b>Team</b> (history of team members)</li>
                <li><b>Security</b> (roles)</li>
                <li><b>SLA</b> (latency, retention, frequency…)</li>
                <li><b>Infrastructure</b> (servers, environment, and storage)</li>
                <li><b>Business Rules</b> (data QoS applied to specific business needs)</li>
                <li><b>Custom</b> (space for custom needs)</li>
            </ul>

            <p>A data contract instance in ODCS is therefore the combination of the structural description of the data
                asset along with all the relevant metadata needed for its management and usage.</p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-04-odcs-metamodel.png"
                alt="Elements of an ODCS v3 valid instance">
            <div class="image-caption">Elements of an ODCS v3 valid instance</div>

            <p>Here you can find a <a
                    href="https://bitol-io.github.io/open-data-contract-standard/latest/examples/all/full-example.odcs.yaml">complete
                    example of a data contract instance</a> compliant with the ODCS.</p>

            <h2>Data Product Descriptor Specification</h2>

            <p><b>Data Product Descriptor Specification (DPDS)</b> is a well-known example of a Data Product
                Specification (DPS) developed by the <a href="https://initiative.opendatamesh.org/">Open Data Mesh
                    Initiative</a>.</p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-05-dpds.png"
                alt="Data Product Descriptor Specification (DPDS)">
            <div class="image-caption">Data Product Descriptor Specification (DPDS)</div>

            <p>Since there is no single, universally accepted definition of a data product, all existing DPSs take an
                opinionated approach to how a data product should be structured and what its key components are. That
                said, the main DPSs currently available largely align with the concept of pure data products, where each
                product is made up of interfaces, often grouped into ports, and internal components, typically divided
                into application and infrastructural components.</p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-06-pure-data-product-anatomy.png"
                alt="Pure Data Product Structure">
            <div class="image-caption">Pure Data Product Structure</div>

            <p>DPDS follows this vision of data product structure in defining its metamodel, which is illustrated at a
                high level in the following image.</p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-07-dpds-meta-model.png"
                alt="DPDS Metamodel">
            <div class="image-caption">DPDS Metamodel</div>

            <p>Specifically, the DPDS metamodel describes a data product through a descriptor object that is composed
                of:</p>

            <ol>
                <li>one object that contains all general information about the data product (<b>Info Object</b>),</li>
                <li>six types of ports (<b>Input, Output, Discoverability, Observability, and Control Ports</b>),</li>
                <li>three types of internal components (<b>Lifecycle Info, Application Components, and Infrastructural
                        Components</b>).</li>
            </ol>

            <p>To define the structure of a specific data product, DPDS uses <a
                    href="https://dpds.opendatamesh.org/specifications/dpds/1.0.0/schema/">JSON Schema</a> as its schema
                definition language (SCD), accepting both YAML and JSON as encoding formats.</p>

            <pre><code>{
                "dataProductDescriptor": "1.0.0",
            
                "info": {
                    "name": "tripExecution",
                    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1"
                },
            
                "interfaceComponents": {
                  "inputPorts": [{
                    "name": "transportManagementSystem",
                    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:transportManagementSystem"
                  }],
                  "outputPorts": [{
                    "name": "tripStatus",
                    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:tripStatus"
                  }]
               },
            
               "internalComponents": {
                 "applicationComponents": [{
                   "name": "cdcIngestionApp",
                   "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:cdcIngestionApp"
                 },{
                   "name": "eventProcessorApp",
                   "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:eventProcessorApp"
                 },{
                   "name": "dbSinkConnectorApp",
                   "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:applications:dbSinkConnectorApp"
                 }],
                 "infrastructuralComponents": [{
                   "name": "eventStore",
                   "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:eventStore"
                 },{
                   "name": "stateStore",
                   "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:infrastructure:stateStore"
                 }]
              }
            }</code></pre>

            <p>Like ODCS, DPDS not only defines the structure of the object of interest — in this case, a data product —
                but also allows for enriching it with additional metadata. To achieve this, keywords used for annotation
                are organized into vocabularies, grouping them based on function or the element they describe (e.g.,
                <i>API, SLO, usage, contact points,</i> etc.).
            </p>

            <p>In DPDS, each component of a data product has its dedicated vocabulary or set of associated vocabularies.
                For instance, every port, regardless of its specific type, can be annotated using keywords defined in
                one of the following three vocabularies:</p>

            <ol>
                <li><b>Promises:</b> Contains all the keywords useful for specifying the intent of the port. Promises
                    are not a guarantee of the outcome but the data product will behave accordingly to them to realize
                    its intent. Examples of annotations defined in promises vocabulary are <i>API, SLO, deprecation
                        policy, etc.</i></li>
                <li><b>Expectations:</b> Contains all the keywords useful to specify how the port should be used by
                    consumers. They are a way to explicitly state what promises the data product would like consumers to
                    make regarding how they will use the port. Examples of annotations defined in expectations
                    vocabulary are <i>intended usage, intended audience, etc.</i></li>
                <li><b>Obligations:</b> Contains all the keywords useful to specify promises and expectations that must
                    be respected both by the data product and its consumers respectively. An obligation is an explicit
                    agreement between the data product and its consumers. It is used to group all the promises and
                    expectations that if not respected can generate penalties like monetary sanctions or interruption of
                    service. Examples of annotations defined in obligations vocabulary are <i>terms of conditions, SLA,
                        billing policy, etc.</i></li>
            </ol>

            <p>Here you can find a <a
                    href="https://github.com/opendatamesh-initiative/odm-specification-dpdescriptor/tree/main/examples/tripexecution">complete
                    example</a> of a data product described using DPDS.</p>


            <h2>Common overlaps</h2>

            <p>Since, in managing the data-as-a-product paradigm, data assets and data products are closely related, it
                is natural for the two types of specifications to have some overlaps, even though their primary focus is
                on describing different objects.</p>

            <img class="normal-image"
                src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-08-overlaps.png"
                alt="Common Overlaps">
            <div class="image-caption">Common Overlaps</div>

            <p>For example, both types of specifications include general information about the described object, which
                applies whether the object is a data asset or a data product (e.g., <i>description, ownership, contact
                    channels, purpose, external documentation, tags, etc.</i>).</p>

            <p>Furthermore, in DCS, making a data asset accessible and consumable requires specifying the serving system
                and its API. This block of metadata naturally overlaps with the definition of output ports in a DPS.</p>

            <p>Similarly, in a DPS, making exposed data assets truly consumable requires more than just describing the
                access APIs; it also involves defining the schema of the data assets they expose. This creates potential
                overlaps with the data asset structure and annotations described within DCS.</p>

            <h2>Integration points</h2>

            <p>Despite potential overlaps, the two types of specifications can be used in a fully complementary way. A
                DPS can be used to define the structure of a data product while a DCS can be used to describe the
                structure of the data assets exposed through its output ports.</p>

            <p>For example, in DPDS, most structural components of a data product can be extended with <a
                    href="https://dpds.opendatamesh.org/specifications/dpds/1.0.0/#specification-extensions"
                    target="_blank">custom properties</a>. This allows each port element to include a custom property
                called <code>x-dataContract</code>, which serves as a reference to the definition of the data contract
                in use.</p>

            <p>The value of the property <code>x-dataContract</code> can be a simple string containing the identifier of
                the referred data contract like in the following example or a <a
                    href="https://dpds.opendatamesh.org/specifications/dpds/1.0.0/#standard-definition-component"
                    target="_blank"><strong>Standard Definition Component</strong></a>.</p>

            <pre><code class="language-json">
{
  "dataProductDescriptor": "1.0.0",
  "info": {
    "name": "tripExecution",
    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1"
  },
  "outputPorts": [{
    "name": "tripStatus",
    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:tripStatus",
    "promises": {
      "api": {
        "specification": "datastoreapi",
        "specificationVersion": "1.0.0",
        "definition": {
          "mediaType": "text/json",
          "$ref": "trip-status-oport-api.json"
        }
      },
      "x-dataContract": "53581432-6c55-4ba2-a65f-72344a91553a"
    }
  }]
}
            </code></pre>

            <p>In DPDS, <strong>Standard Definition Components</strong> are used to incorporate component definitions
                based on external specifications. For instance, port APIs are always defined using <strong>Standard
                    Definition Components</strong>, enabling them to be described using external API specifications such
                as OpenAPI, AsyncAPI, or DatastoreAPI.</p>

            <p>Through the <code>x-dataContract</code> custom property of type <strong>Standard Definition
                    Components</strong>, it’s possible to include in the data product descriptor an external DCS and use
                it to define the data contract for the port. The following is an example of an output port defined in
                DPDS, with its data contract specified using ODCS.</p>

            <pre><code class="language-json">
{
  "dataProductDescriptor": "1.0.0",
  "info": {
    "name": "tripExecution",
    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1"
  },
  "outputPorts": [{
    "name": "tripStatus",
    "fqn": "urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:tripStatus",
    "promises": {
      "api": {
        "specification": "datastoreapi",
        "specificationVersion": "1.0.0",
        "definition": {
          "mediaType": "text/json",
          "$ref": "trip-status-oport-api.json"
        }
      },
      "x-dataContract": {
        "specification": "odcs",
        "specificationVersion": "3.0.0",
        "definition": {
          "mediaType": "text/yaml",
          "$ref": "trip-status-oport-contract.yaml"
        }
      }
    }
  }]
}
            </code></pre>

            <p>The same approach applies to ODCS, where the <a
                    href="https://bitol-io.github.io/open-data-contract-standard/latest/#custom-properties"
                    target="_blank"><code>customProperties</code></a> object can be used to specify the fully qualified
                name of the output port within a data product — defined using DPDS — that exposes the data asset
                governed by the data contract.</p>

            <pre><code class="language-yaml">version: 1.0.0

schema:
  - name: trip_status
    logicalType: object
    properties:
      - name: id
        logicalType: integer
      - name: status
        logicalType: string
      - name: position
        logicalType: string
      - name: last_status_update
        logicalType: date

    customProperties:
        servedBy: urn:dpds:com.company-xyz:dataproducts:tripExecution:1:outputports:tripStatus
        
        </code></pre>

            <h2>Wrapping up</h2>

            <p>The term <strong>data contract</strong> refers to all agreements between a data producer and its
                consumers. In theory, it can be used to describe both agreements related to the data asset being
                exchanged and those related to the data product that manages and delivers the data asset.</p>

            <p>However, in practice, the specifications that have emerged in recent years have become quite polarized,
                with some focusing on describing the data asset (i.e. data contract specification) and others on
                describing the data product that delivers the data asset (i.e. data product specification). We’ve
                specifically explored <strong>ODCS</strong> as an example of the first type of specification and
                <strong>DPDS</strong> as an example of the second.</p>

            <p>Despite some overlap between these two types of specifications, both are extremely valuable in a modular
                and potentially distributed data solution for governing how data is exchanged, used, and composed within
                the ecosystem.</p>

            <p>We’ve seen in this post how to use them complementarily — leveraging DPS to describe a data product and
                DCS to define the agreements on its output ports.</p>

            <p><img src="https://github.com/andrea-gioia/TheDataJoy/raw/main/blogs/2025/b002-data-contract-vs-data-product-specifications/images/2025-B002-09-dpds-with-odcs.png"
                    alt="DPS ❤️ DCS" /></p>

            <p>In my view, this separation of concerns between the two specifications allows each to be used to its
                fullest potential, taking advantage of their unique features while avoiding unnecessary overlap.</p>

            <p>Using them together also helps prevent the creation of monolithic specifications that try to cover all
                aspects of data management, promoting instead the development of smaller, more focused specifications
                that can be easily composed in various ways depending on the needs of each specific context. I’ll dive
                deeper into the topic of <strong>specification composability</strong> and how it can help with the
                adoption and standardization process in the next post.</p>

            <p>Thanks for reading this far! I’m eager to hear your thoughts on DPS and DCS: <em>are they enemies,
                    friends, or frenemies?</em></p>



        </div>

        <div class="resources-box">
            <h2>Resources</h2>
            <ol>
                <li>For a deeper understanding of data contracts, I recommend <a
                        onclick="window.open('https://a.co/d/fWBxJqU', '_blank')">Driving Data Quality with Data
                        Contracts</a> by <b>Andrew Jones</b>.</li>
                <li>Instead, to learn how to apply data contracts specifically within the data mesh paradigm, check out
                    <a onclick="window.open('https://a.co/d/fWBxJqU', '_blank')">Implementing Data Mesh</a> by
                    <b>Jean-Georges Perrin</b> and <b>Eric Broda</b>.
                </li>
                <li>Finally, if you’re interested in exploring pure data products, feel free to refer to my book, <a
                        href="../../book/book.html">Managing Data as a Product<a> 😀</li>

            </ol>
        </div>

    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // Menu toggle functionality
            const menuToggle = document.querySelector('.menu-toggle');
            const nav = document.querySelector('nav');
            const container = document.querySelector('.container');

            menuToggle.addEventListener('click', function () {
                nav.classList.toggle('active');

                // Adjust container padding when menu is expanded
                if (nav.classList.contains('active')) {
                    container.classList.add('menu-expanded');
                } else {
                    container.classList.remove('menu-expanded');
                }
            });
        });
    </script>

     <!-- Google tag (gtag.js) -->
     <script async src="https://www.googletagmanager.com/gtag/js?id=G-37CXXRXWNC"></script>
     <script>
         window.dataLayer = window.dataLayer || [];
         function gtag() { dataLayer.push(arguments); }
         gtag('js', new Date());
 
         gtag('config', 'G-37CXXRXWNC');
     </script>
</body>

</html>